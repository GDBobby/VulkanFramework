#include "EightWinds/RenderGraph/RenderGraph.h"

#include "EightWinds/Backend/PerFlightDebugViewer.h"

namespace EWE{

    void SynchronizationManager::AddTransition_Buffer(GPUTask& lhs, uint32_t lh_index, GPUTask& rhs, uint32_t rh_index) {
        buffer_transitions.emplace_back(
            TransitionObjects<Buffer>{
                .lhs = &lhs,
                .lh_index = lh_index,
                .rhs = &rhs,
                .rh_index = rh_index
            }
        );
    }

    void SynchronizationManager::AddTransition_Image(GPUTask& lhs, uint32_t lh_index, GPUTask& rhs, uint32_t rh_index) {
        image_transitions.emplace_back(
            TransitionObjects<Image>{
                .lhs = &lhs,
                .lh_index = lh_index,
                .rhs = &rhs,
                .rh_index = rh_index
            }
        );
    }
    void SynchronizationManager::AddAcquisition_Buffer(GPUTask& rhs, uint32_t rh_index) {
        buffer_acquisitions.emplace_back(
            AcquireObjects<Buffer>{
                .rhs = &rhs,
                .rh_index = rh_index
            }
        );
    }
    void SynchronizationManager::AddAcquisition_Image(GPUTask& rhs, uint32_t rh_index) {
        image_acquisitions.emplace_back(
            AcquireObjects<Image>{
                .rhs = &rhs,
                .rh_index = rh_index
            }
        );
    }

    void SynchronizationManager::PopulateTasks(){
        for (auto& trans : buffer_transitions) {
            if (trans.lhs->queue != trans.rhs->queue) {
                //put a suffix on lhs
                trans.lhs->suffix.bufferTransitions.emplace_back(trans.lhs->resources, trans.lh_index, trans.rhs->resources, trans.rh_index);
            }

            trans.rhs->prefix.bufferTransitions.emplace_back(trans.lhs->resources, trans.lh_index, trans.rhs->resources, trans.rh_index);
        }
        for (auto& trans : image_transitions) {
            if (trans.lhs->queue != trans.rhs->queue) {
                //put a suffix on lhs
                trans.lhs->suffix.imageTransitions.emplace_back(trans.lhs->resources, trans.lh_index, trans.rhs->resources, trans.rh_index);
            }

            trans.rhs->prefix.imageTransitions.emplace_back(trans.lhs->resources, trans.lh_index, trans.rhs->resources, trans.rh_index);

        }
        for (auto& acq : buffer_acquisitions) {
            acq.rhs->prefix.bufferAcquisitions.emplace_back(acq.rhs->resources, acq.rh_index);
        }
        for (auto& acq : image_acquisitions) {
            acq.rhs->prefix.imageAcquisitions.emplace_back(acq.rhs->resources, acq.rh_index);
        }
    }


    RenderGraph::RenderGraph(LogicalDevice& logicalDevice, Swapchain& swapchain)
        : logicalDevice{logicalDevice},
        swapchain{swapchain},
        presentBridge{logicalDevice, swapchain.presentQueue},
        presentSubmission{ swapchain, swapchain.presentQueue }
    {
#if EWE_DEBUG_BOOL
        printf("need visual feedback for this\n");

        printf("need to see task to task ordering, dependencies, bridges\n");
        printf("need to see each barrier generated by bridges, each resource in use, each pipe in use, EVERYTHING\n");
#endif
        
        presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
        presentInfo.pNext = nullptr;
        presentInfo.pResults = &presentResult;
        presentInfo.swapchainCount = 1;
        presentInfo.pSwapchains = &swapchain.activeSwapchain;
        presentInfo.pImageIndices = &swapchain.imageIndex;
        presentInfo.waitSemaphoreCount = 1;
    }

    bool RenderGraph::Acquire(uint8_t frameIndex){
        return swapchain.AcquireNextImage(frameIndex);
    }

    void RenderGraph::Execute(uint8_t frameIndex) {

        std::string_view name0 = execution_order[0][0]->name;
        std::string_view name1 = execution_order[0][1]->name;
        std::string_view name2 = execution_order[1][0]->name;
        PerFlightDebugViewer temp0{ execution_order[0][0]->submitInfo };
        PerFlightDebugViewer temp1{ execution_order[0][1]->submitInfo };
        PerFlightDebugViewer temp2{ execution_order[1][0]->submitInfo };

        //std::vector<VkSemaphoreSubmitInfo> signaledSemaphores{};
        for (std::size_t i = 0; i < execution_order.size(); i++) {
            std::vector<VkSubmitInfo2> subInfos{};
            Queue* queue = nullptr;
            for(auto& ind_sub : execution_order[i]) {
                //populate sumibssion
                //potentially assert each queue is identical per submission group
                queue = &ind_sub->queue;
                ind_sub->Execute(frameIndex);

                if(ind_sub->signal){
                    subInfos.push_back(ind_sub->submitInfo[frameIndex].Expand());
                    //std::copy(signaledSemaphores.end(), ind_sub->submitInfo[frameIndex].signalSemaphores.begin(), ind_sub->submitInfo[frameIndex].signalSemaphores.end());
                    //std::copy(previous.waitSemaphores.begin(), previous.waitSemaphores.end(), std::back_inserter(waitSemaphores));
                }
                else{
                    subInfos.push_back(ind_sub->submitInfo[frameIndex].ExpandWithoutSignal());
                }
            }
#if EWE_DEBUG_BOOL
            assert(queue != nullptr);
#endif
            for (auto& subIn : subInfos) {
                assert(subIn.commandBufferInfoCount > 0);
            }

#if 1 //TEMP INSANITY DEBUGGING
            //back group wants inflightfence??
            auto& sem0 = swapchain.acquire_semaphores[0];
            auto& sem1 = swapchain.acquire_semaphores[1];
            std::vector<VkSemaphoreSubmitInfo> waitInfos{};
            for (uint32_t i = 0; i < subInfos[0].waitSemaphoreInfoCount; i++) {
                waitInfos.push_back(subInfos[0].pWaitSemaphoreInfos[i]);
            }
#endif

            if (i == (execution_order.size() - 1)) {
                queue->Submit2(subInfos.size(), subInfos.data(), swapchain.inFlightFences[frameIndex]);
            }
            else {
                queue->Submit2(subInfos.size(), subInfos.data(), VK_NULL_HANDLE);
            }
        }
    }
}