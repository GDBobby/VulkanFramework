#include "EightWinds/RenderGraph/RenderGraph.h"

namespace EWE{
    RenderGraph::RenderGraph(LogicalDevice& logicalDevice, Swapchain& swapchain)
        : logicalDevice{logicalDevice},
        swapchain{swapchain},
        presentBridge{logicalDevice, swapchain.presentQueue}
    {
#if EWE_DEBUG_BOOL
        printf("need visual feedback for this\n");

        printf("need to see task to task ordering, dependencies, bridges\n");
        printf("need to see each barrier generated by bridges, each resource in use, each pipe in use, EVERYTHING\n");
#endif
        
        presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
        presentInfo.pNext = nullptr;
        presentInfo.pResults = &presentResult;
        presentInfo.swapchainCount = 1;
        presentInfo.pSwapchains = &swapchain.activeSwapchain;
        presentInfo.pImageIndices = &swapchain.imageIndex;
        presentInfo.waitSemaphoreCount = 1;
    }

    bool RenderGraph::Acquire(uint8_t frameIndex){
        return swapchain.AcquireNextImage(frameIndex);
    }

    void RenderGraph::Execute(CommandBuffer& cmdBuf, uint8_t frameIndex) {

        std::vector<VkSemaphoreSubmitInfo> signaledSemaphores{};
        for(auto& subgroup : execution_order){
            std::vector<VkSubmitInfo2> submissions{};
            for(auto& ind_sub : subgroup){
                //populate sumibssion
                //separate by queue if necessary

                if(ind_sub->signal){
                    submissions.push_back(ind_sub->submitInfo[frameIndex].ExpandWithoutSignal());
                    std::copy(signaledSemaphores.end(), ind_sub->submitInfo[frameIndex].signalSemaphores.begin(), ind_sub->submitInfo[frameIndex].signalSemaphores.end());
                }
                else{
                    submissions.push_back(ind_sub->submitInfo[frameIndex].Expand());
                }
            }
            //queue.Submit2(submissions.size(), submissions.data(), VK_NULL_HANDLE);
        }
        presentInfo.pWaitSemaphores = &swapchain.swap_image_package[swapchain.imageIndex].present_semaphore.vkSemaphore;
    }

    void RenderGraph::PresentBridge(CommandBuffer& cmdBuf) {
        presentBridge.Execute(cmdBuf);
    }

    void RenderGraph::Present(){
        vkQueuePresentKHR(swapchain.presentQueue, &presentInfo);
        swapchain.imageIndex = (swapchain.imageIndex + 1) % swapchain.swap_image_package.size();
    }
}