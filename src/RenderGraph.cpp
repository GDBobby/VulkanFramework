#include "EightWinds/RenderGraph/RenderGraph.h"

namespace EWE{
    RenderGraph::RenderGraph(LogicalDevice& logicalDevice, Swapchain& swapchain)
        : logicalDevice{logicalDevice},
        swapchain{swapchain},
        presentBridge{logicalDevice, swapchain.presentQueue}
    {
#if EWE_DEBUG_BOOL
        printf("need visual feedback for this\n");

        printf("need to see task to task ordering, dependencies, bridges\n");
        printf("need to see each barrier generated by bridges, each resource in use, each pipe in use, EVERYTHING\n");
#endif
        
        presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
        presentInfo.pNext = nullptr;
        presentInfo.pResults = &presentResult;
        presentInfo.swapchainCount = 1;
        presentInfo.pSwapchains = &swapchain.activeSwapchain;
        presentInfo.pImageIndices = &swapchain.imageIndex;
        presentInfo.waitSemaphoreCount = 1;
    }

    bool RenderGraph::Acquire(uint8_t frameIndex){
        return swapchain.AcquireNextImage(frameIndex);
    }

    void RenderGraph::Execute(CommandBuffer& cmdBuf, uint8_t frameIndex) {

        for (auto& task : execution_order) {
            task.Execute();
        }
        presentInfo.pWaitSemaphores = &swapchain.swap_image_package[swapchain.imageIndex].present_semaphore.vkSemaphore;
    }

    void RenderGraph::PresentBridge(CommandBuffer& cmdBuf) {
        presentBridge.Execute(cmdBuf);
    }

    void RenderGraph::Present(){
        vkQueuePresentKHR(swapchain.presentQueue, &presentInfo);
        swapchain.imageIndex = (swapchain.imageIndex + 1) % swapchain.swap_image_package.size();
    }
}