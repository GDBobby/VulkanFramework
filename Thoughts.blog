# 11/6
## ownership

I'm not sure about the current structure. I want Command Buffer (for example) to have a reference to the CommandPool that created it,
and I want that commandPool to have a reference to it's device, and so on, but I also want CommandPool to own that CommandBuffer.
So that when the CommandPool is destructed, so is the CommandBuffer.

My current thoughts are to make it so tha CommandBuffer has a reference to CommandPool, and so on, and then I'll come back
and make a RAII wrapper that would assign ownership. I'm not really sure if it's necessary though, 
that might be more in the engine space, rather than framework space. Nothing should ever use a CommandBuffer after it's owning
CommandPool is destructed however, so I'm unsure.


## structure
I'm tempted to design the framework around a main thread, and auxilary threads. For example, a special command pool could be
designed to facilitate the render graph on the main thread, while a different specialized command pool could be designed to
support short lived work, like transfers. I'll have to see how it evolves

## thoughts
i feel like I'm creating a wrapper around a wrapper (vulkan.hpp). vulkanhpp feels completely redundant

# 11/15
## Device Specialization
One of the big things I wanted to address was logical device specialization. I don't know how I would've worded that before, but that's
where I'm at with it. Device Specialization is defined by API version, then extensions, then features. Properties are also tied to
specialization, but they're more of a result than an input. Anyways, that led me to EightWinds/DeviceSpecialization/ (the entire folder as of now).
Using EightWinds/DeviceSpecialization/DeviceSpecialization.h, the user can use template arguments of featuremanager and property manager (found in FeatureProperty.h)
and the ExtensionManager (found in ExtensionHandler.h) to specialize the device AT COMPILE TIME. At run time, extensions will be filtered,
and extension support can be polled at runtime. The main purpose of this, overall, is that an engine/application
can specialize the device without a large amount of handwritten code, and without cracking open the framework. This amount of templates is
going to harm compile time, but with a bit of effort, an engine should be able to mask DeviceSpecialization. 

## Device Scoring
This isn't finalized yet. But the idea is that each vulkan struct (im planning on separately scoring extensions) can be scored 
in a method similar to std::hash. https://github.com/GDBobby/VulkanFramework/blob/086ad9375f5c60279580fad8696a5b4c5a50a119/include/EightWinds/Helpers/DeviceScoring.h#L76C1-L82C7
Using this function, a default scoring method can be provided, and the plan is, the default can be easily overridden by an end-user
that might want to prefer different options. But ideally, this would be publicly sourced and people more knowledgeable than me could
help with default values.

## fully optional
I want the provided device specialization and device scoring to be fully customizable and optional. It would be a shame
if someone was like "yeah I like everythign in here, except this one part" and that one part makes the entire thing unusable.
I've been there with a few libs.

## thoughts
it's coming to a close, basically all I need now is pipelines. i'm having a big issue, in that I want the user to fully specialize the device, but
i need to be able to access at least a few properties from within the framework. that would be uniform buffer minimum alignment and so on.

## 11/15
i'm curious if hooking (runtime assembly manipulation) would be the most optimal optimization route for extension branching. Only 1 direction will be taken in the branch
for the entire runtime. So, my hypothesis is not branching at all, just inject the correct path.

## 11/21
it's pretty much all there. i'm not sure if i have the patience to complete the render graph before i get the first triangle render or not.
it wouldn't take long to just get the triangle on screen, but it won't be very productive, give nthat i'll have to just go back and erase all
of the temp code, and replace it with healthy longer term systems. i've never done a render graph before, BUT, i recently watched a Vulkanized
video talking about optimizing rendergraphs down to the spirv level. seems exciting, i probably won't be that ambitious, BUT, i'd like to keep
that in mind.

the goal I have right now, i'd like to be able to compile a level based engine's rendergraph. basically, i'll have a small area (probably less than 100m, up to 1km-ish)
and a number of resources (descriptors, buffers, images) to make that happen. The idea, is these resources are tied to the lifetime of this level, nothing more nothing less.
POTENTIALLY, a certain type of entity could have a more precise scope than the entire level, and have resources tied to it, but the level comes first. levels MAY be transferable
to chunks in an open world game, idk. 

ANYWAYS, the plan is to register commands to a framework-level command buffer, as opposed to directly recording to VkCommandBuffer. It'll be a bit
similar to global state tracking, if a draw is commanded, it'll check the command binded descriptors, which will give information on their required
buffers and images, along with the status, read or write. Given that, I can then set a priority, probably just setting what the task needs to be done
before which other task (with the final task being a submit).

I'm not too sure how to give the buffers/images meaningful IDs that don't also require hashmaps for some kind of lookup, but I'll have to crack that
egg when I get to it.

## 11/22
im not confident in any particular direction, so i'm planning a bit more than usual, and moving significantly slower lol. i think building an intricate
series of commands is the way to go. I suspect it'll be transferable to GPU work graphs (not that either of my cards support that, or probably ever will)

but anyways, real talk, the plan is to have three functions now as opposed to two.
PREVIOUSLY, i had Logic() and Render(), now I want to add RecordRender() and I want to change the old Render() to ExecuteRender()
the concept will be in today's push, 

RecordRender - 

DetailedCommandBuffer will store commands, and it will attach a boolean to some amount of commands. this boolean is a pointer, and
in ExecuteRender, the value of the boolean for that frame is determined, deciding if that group of commands will be executed or not.


ExecuteRender - 

This is going to be similar to the old Render(), but instead of dealing with direct vulkan commands, it'll just deal with booleans that
were defined in the recording. Other data will be updated here, like buffer content, and whatever.
